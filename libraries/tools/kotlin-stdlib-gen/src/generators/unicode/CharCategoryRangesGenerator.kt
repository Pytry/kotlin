/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package generators.unicode

import generators.requireExistingDir
import templates.COPYRIGHT_NOTICE
import templates.KotlinTarget
import templates.autoGeneratedWarning
import java.io.File
import java.io.FileWriter

internal class CharCategoryRangesGenerator(
    private val outputFile: File,
    target: KotlinTarget
) : UnicodeDataGenerator {
    private val start = mutableListOf<Int>()
    private val end = mutableListOf<Int>()
    private val category = mutableListOf<MutableList<String?>>()
    private val writingStrategy = WritingRangesStrategy.of(target)

    init {
        outputFile.parentFile.requireExistingDir()
    }

    override fun appendChar(char: String, name: String, categoryCode: String) {
        val charCode = char.toInt(radix = 16)

        require(charCode == 0 || start.isNotEmpty())

        if (start.isEmpty() || name.endsWith(", First>")) {
            start.add(charCode)
            end.add(charCode)
            category.add(mutableListOf(categoryCode, null))
            return
        }
        if (name.endsWith(", Last>")) {
            end[end.lastIndex] = charCode
            check(category.last().first() == categoryCode)
            return
        }

        val lastCategory = category.last()[charCode and 1]

        if (end.last() == charCode - 1 && (lastCategory == null || lastCategory == categoryCode)) {
            end[end.lastIndex] = charCode
            category.last()[charCode and 1] = categoryCode
        } else {
            start.add(charCode)
            end.add(charCode)
            category.add(mutableListOf(null, null))
            category.last()[charCode and 1] = categoryCode
        }
    }

    override fun close() {
        FileWriter(outputFile).use { writer ->
            println("Generating file: $outputFile")
            writer.appendLine(COPYRIGHT_NOTICE)
            writer.appendLine("package kotlin.text")
            writer.appendLine()
            writer.appendLine(autoGeneratedWarning("GenerateUnicodeData.kt"))
            writer.appendLine()
            writeRanges(writer)
            writer.appendLine()
            writer.appendLine(binarySearch())
            writer.appendLine()
            writer.appendLine(getCategoryValue())
        }
    }

    private fun writeRanges(writer: FileWriter) {
        writingStrategy.beforeWritingRanges(writer)
        writer.writeIntArray("rangeStart", start) { it }
        writer.appendLine()
        writer.writeIntArray("rangeEnd", end) { it }
        writer.appendLine()

        val categoryCodeToValue = CharCategory.values().associateBy({ it.code }, { it.value })

        writer.writeIntArray("categoryOfRange", category) { (even, odd) ->
            if (even == null || odd == null || even == odd) {
                categoryCodeToValue[even ?: odd]!!
            } else {
                categoryCodeToValue[even]!! + (categoryCodeToValue[odd]!! shl 8)
            }
        }
        writingStrategy.afterWritingRanges(writer)
    }

    private fun <E> FileWriter.writeIntArray(name: String, elements: List<E>, transform: (E) -> Int) {
        appendWithIndentation("${writingStrategy.rangesVisibilityModifier} val $name = intArrayOf(")
        for (i in elements.indices) {
            if (i % 20 == 0) {
                appendLine()
                appendWithIndentation("    ")
            }
            val value = transform(elements[i])
            append("0x${value.hex()}, ")
        }
        appendLine()
        appendWithIndentation(")")
        appendLine()
    }

    private fun FileWriter.appendWithIndentation(string: String) {
        append(writingStrategy.indentation + string)
    }

    private fun Int.hex(): String = toString(radix = 16).padStart(4, '0')

    private fun binarySearch(): String = """
        private fun binarySearchRange(array: IntArray, needle: Int): Int {
            var bottom = 0
            var top = array.size - 1
            var middle = -1
            var value = 0
            while (bottom <= top) {
                middle = (bottom + top) / 2
                value = array[middle]
                if (needle > value)
                    bottom = middle + 1
                else if (needle == value)
                    return middle
                else
                    top = middle - 1
            }
            return middle - (if (needle < value) 1 else 0)
        }
        """.trimIndent()

    private fun getCategoryValue(): String = """
        /**
         * Returns the Unicode general category of this character as an Int.
         */
        internal fun Char.getCategoryValue(): Int {
            val ch = this.toInt()
            val index = binarySearchRange(${writingStrategy.rangeReference("rangeStart")}, ch)
            val high = ${writingStrategy.rangeReference("rangeEnd[index]")}
            if (ch <= high) {
                val code = ${writingStrategy.rangeReference("categoryOfRange")}[index]
                if (code < 0x100) {
                    return code
                }
                return if ((ch and 1) == 1) code shr 8 else code and 0xff
            }
            return CharCategory.UNASSIGNED.value
        }
        """.trimIndent()
}

private sealed class WritingRangesStrategy {
    abstract val indentation: String
    abstract val rangesVisibilityModifier: String
    abstract fun beforeWritingRanges(writer: FileWriter)
    abstract fun afterWritingRanges(writer: FileWriter)
    abstract fun rangeReference(name: String): String

    companion object {
        fun of(target: KotlinTarget): WritingRangesStrategy {
            return when (target) {
                KotlinTarget.JS, KotlinTarget.JS_IR -> JsWritingRangesStrategy
                else -> DummyWritingRangesStrategy
            }
        }
    }
}

private object DummyWritingRangesStrategy : WritingRangesStrategy() {
    override val indentation: String get() = ""
    override val rangesVisibilityModifier: String get() = "private"
    override fun beforeWritingRanges(writer: FileWriter) {}
    override fun afterWritingRanges(writer: FileWriter) {}
    override fun rangeReference(name: String): String = name
}

// see KT-42461
private object JsWritingRangesStrategy : WritingRangesStrategy() {
    override val indentation: String get() = "        " // 8 spaces
    override val rangesVisibilityModifier: String get() = "internal"

    override fun beforeWritingRanges(writer: FileWriter) {
        writer.appendLine("private class RangesWrapper {")
        writer.appendLine("    companion object {")
    }

    override fun afterWritingRanges(writer: FileWriter) {
        writer.appendLine("    }")
        writer.appendLine("}")
    }

    override fun rangeReference(name: String): String = "RangesWrapper.$name"
}
